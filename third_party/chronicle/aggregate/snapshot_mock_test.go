// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package aggregate_test

import (
	"context"
	"github.com/DeluxeOwl/chronicle/aggregate"
	"github.com/DeluxeOwl/chronicle/event"
	"github.com/DeluxeOwl/chronicle/version"
	"sync"
)

// SnapshotStoreMock is a mock implementation of aggregate.SnapshotStore.
//
//	func TestSomethingThatUsesSnapshotStore(t *testing.T) {
//
//		// make and configure a mocked aggregate.SnapshotStore
//		mockedSnapshotStore := &SnapshotStoreMock{
//			GetSnapshotFunc: func(ctx context.Context, aggregateID TID) (TS, bool, error) {
//				panic("mock out the GetSnapshot method")
//			},
//			SaveSnapshotFunc: func(ctx context.Context, snapshot TS) error {
//				panic("mock out the SaveSnapshot method")
//			},
//		}
//
//		// use mockedSnapshotStore in code that requires aggregate.SnapshotStore
//		// and then make assertions.
//
//	}
type SnapshotStoreMock[TID aggregate.ID, TS aggregate.Snapshot[TID]] struct {
	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx context.Context, aggregateID TID) (TS, bool, error)

	// SaveSnapshotFunc mocks the SaveSnapshot method.
	SaveSnapshotFunc func(ctx context.Context, snapshot TS) error

	// calls tracks calls to the methods.
	calls struct {
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AggregateID is the aggregateID argument value.
			AggregateID TID
		}
		// SaveSnapshot holds details about calls to the SaveSnapshot method.
		SaveSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Snapshot is the snapshot argument value.
			Snapshot TS
		}
	}
	lockGetSnapshot  sync.RWMutex
	lockSaveSnapshot sync.RWMutex
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotStoreMock[TID, TS]) GetSnapshot(ctx context.Context, aggregateID TID) (TS, bool, error) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotStoreMock.GetSnapshotFunc: method is nil but SnapshotStore.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		AggregateID TID
	}{
		Ctx:         ctx,
		AggregateID: aggregateID,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, aggregateID)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//
//	len(mockedSnapshotStore.GetSnapshotCalls())
func (mock *SnapshotStoreMock[TID, TS]) GetSnapshotCalls() []struct {
	Ctx         context.Context
	AggregateID TID
} {
	var calls []struct {
		Ctx         context.Context
		AggregateID TID
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// SaveSnapshot calls SaveSnapshotFunc.
func (mock *SnapshotStoreMock[TID, TS]) SaveSnapshot(ctx context.Context, snapshot TS) error {
	if mock.SaveSnapshotFunc == nil {
		panic("SnapshotStoreMock.SaveSnapshotFunc: method is nil but SnapshotStore.SaveSnapshot was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Snapshot TS
	}{
		Ctx:      ctx,
		Snapshot: snapshot,
	}
	mock.lockSaveSnapshot.Lock()
	mock.calls.SaveSnapshot = append(mock.calls.SaveSnapshot, callInfo)
	mock.lockSaveSnapshot.Unlock()
	return mock.SaveSnapshotFunc(ctx, snapshot)
}

// SaveSnapshotCalls gets all the calls that were made to SaveSnapshot.
// Check the length with:
//
//	len(mockedSnapshotStore.SaveSnapshotCalls())
func (mock *SnapshotStoreMock[TID, TS]) SaveSnapshotCalls() []struct {
	Ctx      context.Context
	Snapshot TS
} {
	var calls []struct {
		Ctx      context.Context
		Snapshot TS
	}
	mock.lockSaveSnapshot.RLock()
	calls = mock.calls.SaveSnapshot
	mock.lockSaveSnapshot.RUnlock()
	return calls
}

// SnapshotterMock is a mock implementation of aggregate.Snapshotter.
//
//	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
//		// make and configure a mocked aggregate.Snapshotter
//		mockedSnapshotter := &SnapshotterMock{
//			FromSnapshotFunc: func(v TS) (R, error) {
//				panic("mock out the FromSnapshot method")
//			},
//			ToSnapshotFunc: func(v R) (TS, error) {
//				panic("mock out the ToSnapshot method")
//			},
//		}
//
//		// use mockedSnapshotter in code that requires aggregate.Snapshotter
//		// and then make assertions.
//
//	}
type SnapshotterMock[TID aggregate.ID, E event.Any, R aggregate.Root[TID, E], TS aggregate.Snapshot[TID]] struct {
	// FromSnapshotFunc mocks the FromSnapshot method.
	FromSnapshotFunc func(v TS) (R, error)

	// ToSnapshotFunc mocks the ToSnapshot method.
	ToSnapshotFunc func(v R) (TS, error)

	// calls tracks calls to the methods.
	calls struct {
		// FromSnapshot holds details about calls to the FromSnapshot method.
		FromSnapshot []struct {
			// V is the v argument value.
			V TS
		}
		// ToSnapshot holds details about calls to the ToSnapshot method.
		ToSnapshot []struct {
			// V is the v argument value.
			V R
		}
	}
	lockFromSnapshot sync.RWMutex
	lockToSnapshot   sync.RWMutex
}

// FromSnapshot calls FromSnapshotFunc.
func (mock *SnapshotterMock[TID, E, R, TS]) FromSnapshot(v TS) (R, error) {
	if mock.FromSnapshotFunc == nil {
		panic("SnapshotterMock.FromSnapshotFunc: method is nil but Snapshotter.FromSnapshot was just called")
	}
	callInfo := struct {
		V TS
	}{
		V: v,
	}
	mock.lockFromSnapshot.Lock()
	mock.calls.FromSnapshot = append(mock.calls.FromSnapshot, callInfo)
	mock.lockFromSnapshot.Unlock()
	return mock.FromSnapshotFunc(v)
}

// FromSnapshotCalls gets all the calls that were made to FromSnapshot.
// Check the length with:
//
//	len(mockedSnapshotter.FromSnapshotCalls())
func (mock *SnapshotterMock[TID, E, R, TS]) FromSnapshotCalls() []struct {
	V TS
} {
	var calls []struct {
		V TS
	}
	mock.lockFromSnapshot.RLock()
	calls = mock.calls.FromSnapshot
	mock.lockFromSnapshot.RUnlock()
	return calls
}

// ToSnapshot calls ToSnapshotFunc.
func (mock *SnapshotterMock[TID, E, R, TS]) ToSnapshot(v R) (TS, error) {
	if mock.ToSnapshotFunc == nil {
		panic("SnapshotterMock.ToSnapshotFunc: method is nil but Snapshotter.ToSnapshot was just called")
	}
	callInfo := struct {
		V R
	}{
		V: v,
	}
	mock.lockToSnapshot.Lock()
	mock.calls.ToSnapshot = append(mock.calls.ToSnapshot, callInfo)
	mock.lockToSnapshot.Unlock()
	return mock.ToSnapshotFunc(v)
}

// ToSnapshotCalls gets all the calls that were made to ToSnapshot.
// Check the length with:
//
//	len(mockedSnapshotter.ToSnapshotCalls())
func (mock *SnapshotterMock[TID, E, R, TS]) ToSnapshotCalls() []struct {
	V R
} {
	var calls []struct {
		V R
	}
	mock.lockToSnapshot.RLock()
	calls = mock.calls.ToSnapshot
	mock.lockToSnapshot.RUnlock()
	return calls
}

// SnapshotMock is a mock implementation of aggregate.Snapshot.
//
//	func TestSomethingThatUsesSnapshot(t *testing.T) {
//
//		// make and configure a mocked aggregate.Snapshot
//		mockedSnapshot := &SnapshotMock{
//			IDFunc: func() TID {
//				panic("mock out the ID method")
//			},
//			VersionFunc: func() version.Version {
//				panic("mock out the Version method")
//			},
//		}
//
//		// use mockedSnapshot in code that requires aggregate.Snapshot
//		// and then make assertions.
//
//	}
type SnapshotMock[TID aggregate.ID] struct {
	// IDFunc mocks the ID method.
	IDFunc func() TID

	// VersionFunc mocks the Version method.
	VersionFunc func() version.Version

	// calls tracks calls to the methods.
	calls struct {
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// Version holds details about calls to the Version method.
		Version []struct {
		}
	}
	lockID      sync.RWMutex
	lockVersion sync.RWMutex
}

// ID calls IDFunc.
func (mock *SnapshotMock[TID]) ID() TID {
	if mock.IDFunc == nil {
		panic("SnapshotMock.IDFunc: method is nil but Snapshot.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedSnapshot.IDCalls())
func (mock *SnapshotMock[TID]) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *SnapshotMock[TID]) Version() version.Version {
	if mock.VersionFunc == nil {
		panic("SnapshotMock.VersionFunc: method is nil but Snapshot.Version was just called")
	}
	callInfo := struct {
	}{}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc()
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//
//	len(mockedSnapshot.VersionCalls())
func (mock *SnapshotMock[TID]) VersionCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
