package internal

import (
	"context"
	"log"
	"time"

	"github.com/DeluxeOwl/chronicle/aggregate"
	"github.com/ngnhng/durablefuture/api"
	"github.com/ngnhng/durablefuture/api/serde"
	"github.com/ngnhng/durablefuture/server/utils"
)

type Context interface {
	context.Context

	ExecuteActivity(activityFn any, args ...any) Future

	ID() api.WorkflowID

	GetWorkflowFunctionName() string

	WithValue(key any, value any) Context
}

var _ Context = (*workflowContext)(nil)

type workflowContext struct {
	aggregate.Base

	context.Context

	// sequence is the local event sequence up to now in this Workflow Context
	sequence uint64

	converter serde.BinarySerde

	id                   api.WorkflowID
	workflowFunctionName string

	activityResult map[string][]any
}

func NewEmptyWorkflowContext() *workflowContext {
	return new(workflowContext)
}

func (c *workflowContext) ExecuteActivity(activityFn any, args ...any) Future {

	// c.sequence++
	// decisionOutcomesFound := 0
	// // log.Printf("ExecuteActivity: wfCtx seq: %v", wfCtx.sequence)
	// // log.Printf("ExecuteActivity: wfCtx hist: %v", utils.DebugWorkflowEvents(wfCtx.history))

	// for _, event := range c.history {
	// 	if event.EventType == api.ActivityCompleted || event.EventType == api.ActivityFailed {
	// 		decisionOutcomesFound++

	// 		if decisionOutcomesFound == int(c.sequence) {
	// 			if event.EventType == api.ActivityCompleted {
	// 				// log.Printf("[context Execute Activity]: replaying ActivityCompletedEvent: %v", utils.DebugWorkflowEvents([]api.WorkflowEvent{event}))

	// 				var attrs api.ActivityCompletedAttributes
	// 				_ = json.Unmarshal(event.Attributes, &attrs)
	// 				return &pending{isResolved: true, value: attrs.Result}
	// 			} else {
	// 				log.Printf("[context Execute Activity]: replaying ActivityFailedEvent: %v", event)

	// 				var attrs api.ActivityFailedAttributes
	// 				_ = json.Unmarshal(event.Attributes, &attrs)
	// 				return &pending{isResolved: true, err: fmt.Errorf("%v", attrs.Error)}
	// 			}
	// 		}
	// 	}
	// }

	// --- First-Time Execution Logic ---
	// If we've iterated through the entire history and haven't found the Nth outcome,
	// it means this is a new decision to be made.
	fnName, err := utils.ExtractFullFunctionName(activityFn)
	if err != nil { /* panic */
		log.Printf("error: %v", err)
		panic(err)
	}

	if result, ok := c.activityResult[fnName]; ok {
		return &pending{isResolved: true, value: result}
	}

	log.Printf("[context] will try to schedule execute activity: %v", fnName)
	log.Printf("new activity task scheduled event for: %v with ID: %v", fnName, c.ID())

	c.recordThat(&api.ActivityScheduled{
		ID:             c.ID(),
		WorkflowFnName: c.GetWorkflowFunctionName(),
		ActivityFnName: fnName,
		Input:          args,
	})

	return &pending{isResolved: false}
}

// func getActivityOptions(ctx *ContextImpl) workflow.ActivityOptions {
// 	val := ctx.Value(activityOptionsKey{})
// 	if val == nil {
// 		log.Panic("ActivityOptions not found in context. Please use WithActivityOptions to set it.")
// 	}
// 	opts, ok := val.(workflow.ActivityOptions)
// 	if !ok {
// 		log.Panic("ActivityOptions has wrong type in context.")
// 	}
// 	return opts
// }

func (c *workflowContext) WithValue(key any, value any) Context {
	return &workflowContext{
		sequence:             c.sequence,
		converter:            c.converter,
		id:                   c.id,
		Context:              context.WithValue(c.Context, key, value),
		workflowFunctionName: c.workflowFunctionName,
		activityResult:       c.activityResult,
	}
}

// getNewEvents is an unexported method accessible only within the `workflow` package.
// The executor calls this to retrieve the commands generated by the workflow logic.
func (c *workflowContext) GetWorkflowFunctionName() string         { return c.workflowFunctionName }
func (c *workflowContext) Deadline() (deadline time.Time, ok bool) { return c.Context.Deadline() }
func (c *workflowContext) Done() <-chan struct{}                   { return c.Context.Done() }
func (c *workflowContext) Err() error                              { return c.Context.Err() }
func (c *workflowContext) Value(key any) any                       { return c.Context.Value(key) }
