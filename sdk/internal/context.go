// Copyright 2025 Nguyen Nhat Nguyen
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/DeluxeOwl/chronicle/aggregate"
	"github.com/ngnhng/durablefuture/api"
	"github.com/ngnhng/durablefuture/api/serde"
)

type Context interface {
	context.Context
	ExecuteActivity(activityFn any, args ...any) Future
	ID() api.WorkflowID
	GetWorkflowFunctionName() string
	WithValue(key any, value any) Context
}

var _ Context = (*workflowContext)(nil)

type workflowContext struct {
	*workflowState
	context.Context
	logger *slog.Logger
}

type workflowState struct {
	aggregate.Base
	converter            serde.BinarySerde
	id                   api.WorkflowID
	workflowFunctionName string
	activities           map[string]*activityReplay
}

func NewEmptyWorkflowContext() *workflowContext {
	return NewWorkflowContextWithLogger(nil)
}

func NewWorkflowContextWithLogger(logger *slog.Logger) *workflowContext {
	return &workflowContext{
		workflowState: &workflowState{
			activities: make(map[string]*activityReplay),
		},
		Context: context.Background(),
		logger:  defaultLogger(logger),
	}
}

func (c *workflowContext) ExecuteActivity(activityFn any, args ...any) Future {
	fnName, err := extractFullFunctionName(activityFn)
	if err != nil {
		// TODO: gracefully handle crash here
		c.loggerOrDefault().Error("failed to extract activity function name", "error", err)
		panic(err)
	}
	entry := c.ensureActivityReplay(fnName)

	// During replay we look for an already completed/failed result in order.
	if entry.consumed < len(entry.history) {
		record := entry.history[entry.consumed]
		entry.consumed++
		if record.err != nil {
			return &pending{
				isResolved: true,
				err:        record.err,
				converter:  c.converter,
				logger:     c.logger,
			}
		}
		return &pending{
			isResolved: true,
			value:      record.result,
			converter:  c.converter,
			logger:     c.logger,
		}
	}

	// No cached history entry means this is a fresh execution.
	entry.consumed++

	// Read activity options from context if available
	opts := getActivityOptions(c)
	event := &api.ActivityScheduled{
		ID:             c.ID(),
		WorkflowFnName: c.GetWorkflowFunctionName(),
		ActivityFnName: fnName,
		Input:          args,
	}

	// Populate timeout and retry policy from options
	if opts != nil {
		if opts.ScheduleToCloseTimeout > 0 {
			event.ScheduleToCloseTimeoutUnix = time.Now().Unix() + opts.ScheduleToCloseTimeout.Milliseconds()
		}
		if opts.StartToCloseTimeout > 0 {
			event.StartToCloseTimeoutUnix =
				opts.StartToCloseTimeout.Milliseconds()
		}
		if opts.RetryPolicy != nil {
			event.RetryPolicy = convertRetryPolicyToAPI(opts.RetryPolicy)
		}
	}

	if err := c.recordThat(event); err != nil {
		// recording should never fail during workflow execution; surface loudly if it does
		panic(fmt.Errorf("record activity scheduled event: %w", err))
	}

	return &pending{isResolved: false, converter: c.converter, logger: c.logger}
}

func (c *workflowContext) WithValue(key any, value any) Context {
	baseCtx := c.Context
	if baseCtx == nil {
		baseCtx = context.Background()
	}
	return &workflowContext{
		workflowState: c.workflowState,
		Context:       context.WithValue(baseCtx, key, value),
		logger:        c.logger,
	}
}

func (c *workflowContext) loggerOrDefault() *slog.Logger {
	if c == nil {
		return slog.Default()
	}
	return defaultLogger(c.logger)
}

// getNewEvents is an unexported method accessible only within the `workflow` package.
// The executor calls this to retrieve the commands generated by the workflow logic.
func (c *workflowContext) GetWorkflowFunctionName() string { return c.workflowFunctionName }

func (c *workflowContext) Deadline() (time.Time, bool) {
	if c.Context == nil {
		return time.Time{}, false
	}
	return c.Context.Deadline()
}

func (c *workflowContext) Done() <-chan struct{} {
	if c.Context == nil {
		return nil
	}
	return c.Context.Done()
}

func (c *workflowContext) Err() error {
	if c.Context == nil {
		return nil
	}
	return c.Context.Err()
}

func (c *workflowContext) Value(key any) any {
	if c.Context == nil {
		return nil
	}
	return c.Context.Value(key)
}
