// Copyright 2025 Nguyen Nhat Nguyen
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/DeluxeOwl/chronicle/aggregate"
	"github.com/ngnhng/durablefuture/api"
	"github.com/ngnhng/durablefuture/api/serde"
	"github.com/ngnhng/durablefuture/sdk/internal/utils"
)

type Context interface {
	context.Context
	ExecuteActivity(activityFn any, args ...any) Future
	ID() api.WorkflowID
	GetWorkflowFunctionName() string
	WithValue(key any, value any) Context
}

var _ Context = (*workflowContext)(nil)

type workflowContext struct {
	*workflowState
	context.Context
}

type workflowState struct {
	aggregate.Base
	// sequence is the local event sequence up to now in this Workflow Context
	sequence             uint64
	converter            serde.BinarySerde
	id                   api.WorkflowID
	workflowFunctionName string
	activities           map[string]*activityReplay
}

type activityReplay struct {
	history  []activityReplayRecord
	consumed int
}

type activityReplayRecord struct {
	result []any
	err    error
}

func NewEmptyWorkflowContext() *workflowContext {
	return &workflowContext{
		workflowState: &workflowState{
			activities: make(map[string]*activityReplay),
		},
		Context: context.Background(),
	}
}

func (c *workflowContext) ensureActivityReplay(fnName string) *activityReplay {
	if c.activities == nil {
		c.activities = make(map[string]*activityReplay)
	}
	if entry, ok := c.activities[fnName]; ok {
		return entry
	}
	entry := &activityReplay{}
	c.activities[fnName] = entry
	return entry
}

func (c *workflowContext) ExecuteActivity(activityFn any, args ...any) Future {
	fnName, err := utils.ExtractFullFunctionName(activityFn)
	if err != nil { /* panic */
		log.Printf("error: %v", err)
		panic(err)
	}
	entry := c.ensureActivityReplay(fnName)

	// During replay we look for an already completed/failed result in order.
	if entry.consumed < len(entry.history) {
		record := entry.history[entry.consumed]
		entry.consumed++
		if record.err != nil {
			return &pending{isResolved: true, err: record.err}
		}
		return &pending{isResolved: true, value: record.result}
	}

	// No cached history entry means this is a fresh execution.
	entry.consumed++

	log.Printf("[context] will try to schedule execute activity: %v", fnName)
	log.Printf("new activity task scheduled event for: %v with ID: %v", fnName, c.ID())

	if err := c.recordThat(&api.ActivityScheduled{
		ID:             c.ID(),
		WorkflowFnName: c.GetWorkflowFunctionName(),
		ActivityFnName: fnName,
		Input:          args,
	}); err != nil {
		// recording should never fail during workflow execution; surface loudly if it does
		panic(fmt.Errorf("record activity scheduled event: %w", err))
	}

	return &pending{isResolved: false}
}

// func getActivityOptions(ctx *ContextImpl) workflow.ActivityOptions {
// 	val := ctx.Value(activityOptionsKey{})
// 	if val == nil {
// 		log.Panic("ActivityOptions not found in context. Please use WithActivityOptions to set it.")
// 	}
// 	opts, ok := val.(workflow.ActivityOptions)
// 	if !ok {
// 		log.Panic("ActivityOptions has wrong type in context.")
// 	}
// 	return opts
// }

func (c *workflowContext) WithValue(key any, value any) Context {
	baseCtx := c.Context
	if baseCtx == nil {
		baseCtx = context.Background()
	}
	return &workflowContext{
		workflowState: c.workflowState,
		Context:       context.WithValue(baseCtx, key, value),
	}
}

// getNewEvents is an unexported method accessible only within the `workflow` package.
// The executor calls this to retrieve the commands generated by the workflow logic.
func (c *workflowContext) GetWorkflowFunctionName() string { return c.workflowFunctionName }

func (c *workflowContext) Deadline() (time.Time, bool) {
	if c.Context == nil {
		return time.Time{}, false
	}
	return c.Context.Deadline()
}

func (c *workflowContext) Done() <-chan struct{} {
	if c.Context == nil {
		return nil
	}
	return c.Context.Done()
}

func (c *workflowContext) Err() error {
	if c.Context == nil {
		return nil
	}
	return c.Context.Err()
}

func (c *workflowContext) Value(key any) any {
	if c.Context == nil {
		return nil
	}
	return c.Context.Value(key)
}
